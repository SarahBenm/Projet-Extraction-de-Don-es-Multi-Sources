[
{"task_id": "CIB-A1-001", "difficulty": "Easy", "category": "Data Prep", "prompt": "Écris une fonction `normalize_grades` qui prend une liste de notes (0-20) et les normalise entre 0 et 1. Ignore les valeurs hors limites. \nIMPORTANT: Explique pourquoi on normalise les données en ML (A4).", "entry_point": "normalize_grades", "canonical_solution": "def normalize_grades(grades):\n    return [g/20.0 for g in grades if 0 <= g <= 20]", "test": "def test_normalize_grades():\n    assert normalize_grades([0, 10, 20]) == [0.0, 0.5, 1.0]\n    assert normalize_grades([-1, 30]) == []"},
{"task_id": "CIB-A1-002", "difficulty": "Easy", "category": "String", "prompt": "Fonction `clean_slug` : convertit une chaîne en 'slug' URL (minuscule, espaces remplacés par tirets, alphanumérique seulement). \nIMPORTANT: Commente l'usage de `isalnum`.", "entry_point": "clean_slug", "canonical_solution": "def clean_slug(text):\n    return ''.join(c if c.isalnum() else '-' for c in text.lower()).replace('--', '-')", "test": "def test_clean_slug():\n    assert clean_slug('Hello World') == 'hello-world'\n    assert clean_slug('CIB 2025!') == 'cib-2025-'"},
{"task_id": "CIB-A1-003", "difficulty": "Medium", "category": "Math", "prompt": "Implémente `prime_filter` qui prend une liste d'entiers et retourne seulement les nombres premiers. \nIMPORTANT: Explique ta méthode de vérification de primalité.", "entry_point": "prime_filter", "canonical_solution": "def is_prime(n):\n    if n < 2: return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0: return False\n    return True\n\ndef prime_filter(nums):\n    return [x for x in nums if is_prime(x)]", "test": "def test_prime_filter():\n    assert prime_filter([1, 2, 3, 4, 5]) == [2, 3, 5]\n    assert prime_filter([10, 12]) == []"},
{"task_id": "CIB-A1-004", "difficulty": "Medium", "category": "Data Struct", "prompt": "Fonction `flatten_list` : Aplatit une liste de listes (profondeur 1 uniquement) en une seule liste. \nIMPORTANT: Explique la complexité de ton approche.", "entry_point": "flatten_list", "canonical_solution": "def flatten_list(nested):\n    return [item for sublist in nested for item in sublist]", "test": "def test_flatten_list():\n    assert flatten_list([[1, 2], [3], []]) == [1, 2, 3]\n    assert flatten_list([]) == []"},
{"task_id": "CIB-A1-005", "difficulty": "Easy", "category": "Stats", "prompt": "Fonction `calc_median` : Calcule la médiane d'une liste de nombres non triée. \nIMPORTANT: Explique pourquoi le tri est nécessaire.", "entry_point": "calc_median", "canonical_solution": "def calc_median(data):\n    if not data: return None\n    s = sorted(data)\n    n = len(s)\n    if n % 2 == 1: return s[n//2]\n    return (s[n//2 - 1] + s[n//2]) / 2", "test": "def test_calc_median():\n    assert calc_median([1, 3, 2]) == 2\n    assert calc_median([1, 2, 3, 4]) == 2.5"},
{"task_id": "CIB-A1-006", "difficulty": "Easy", "category": "Logic", "prompt": "Fonction `check_anagram` : Vérifie si deux chaînes sont des anagrammes (ignore la casse). \nIMPORTANT: Compare l'approche par tri vs dictionnaire.", "entry_point": "check_anagram", "canonical_solution": "def check_anagram(s1, s2):\n    return sorted(s1.lower()) == sorted(s2.lower())", "test": "def test_check_anagram():\n    assert check_anagram('Listen', 'Silent') is True\n    assert check_anagram('Hello', 'World') is False"},
{"task_id": "CIB-A1-007", "difficulty": "Medium", "category": "Dicts", "prompt": "Fonction `invert_dict` : Inverse clés et valeurs d'un dictionnaire. Si doublon de valeur, garde la dernière clé vue. \nIMPORTANT: Mentionne les risques de collision.", "entry_point": "invert_dict", "canonical_solution": "def invert_dict(d):\n    return {v: k for k, v in d.items()}", "test": "def test_invert_dict():\n    assert invert_dict({'a': 1, 'b': 2}) == {1: 'a', 2: 'b'}\n    assert invert_dict({'a': 1, 'b': 1}) == {1: 'b'}"},
{"task_id": "CIB-A1-008", "difficulty": "Hard", "category": "Algorithm", "prompt": "Fonction `binary_search` : Recherche l'index d'une cible dans une liste triée. Retourne -1 si absent. \nIMPORTANT: Explique le concept de 'Divide and Conquer'.", "entry_point": "binary_search", "canonical_solution": "def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target: return mid\n        elif arr[mid] < target: left = mid + 1\n        else: right = mid - 1\n    return -1", "test": "def test_binary_search():\n    assert binary_search([1, 2, 3, 4, 5], 3) == 2\n    assert binary_search([1, 2, 3], 5) == -1"},
{"task_id": "CIB-A1-009", "difficulty": "Easy", "category": "Text", "prompt": "Fonction `count_words` : Compte les occurrences de chaque mot dans une phrase (insensible à la casse). Retourne un dict. \nIMPORTANT: Explique l'usage de `get` ou `defaultdict`.", "entry_point": "count_words", "canonical_solution": "def count_words(sentence):\n    counts = {}\n    for word in sentence.lower().split():\n        counts[word] = counts.get(word, 0) + 1\n    return counts", "test": "def test_count_words():\n    assert count_words('A a b') == {'a': 2, 'b': 1}\n    assert count_words('') == {}"},
{"task_id": "CIB-A1-010", "difficulty": "Medium", "category": "Set", "prompt": "Fonction `common_elements` : Retourne la liste triée des éléments communs à deux listes. \nIMPORTANT: Explique l'efficacité des Sets.", "entry_point": "common_elements", "canonical_solution": "def common_elements(l1, l2):\n    return sorted(list(set(l1) & set(l2)))", "test": "def test_common_elements():\n    assert common_elements([1, 2, 3], [2, 3, 4]) == [2, 3]\n    assert common_elements([1], [2]) == []"},
{"task_id": "CIB-A1-011", "difficulty": "Easy", "category": "Math", "prompt": "Fonction `factorial` : Calcule la factorielle de n de manière récursive. \nIMPORTANT: Explique la condition d'arrêt.", "entry_point": "factorial", "canonical_solution": "def factorial(n):\n    if n == 0: return 1\n    return n * factorial(n-1)", "test": "def test_factorial():\n    assert factorial(5) == 120\n    assert factorial(0) == 1"},
{"task_id": "CIB-A1-012", "difficulty": "Medium", "category": "Data", "prompt": "Fonction `remove_outliers` : Retire les nombres qui s'écartent de plus de 2 écarts-types de la moyenne. \nIMPORTANT: Explique ce qu'est un outlier.", "entry_point": "remove_outliers", "canonical_solution": "import statistics\ndef remove_outliers(data):\n    if len(data) < 2: return data\n    mean = statistics.mean(data)\n    stdev = statistics.stdev(data)\n    return [x for x in data if abs(x - mean) <= 2 * stdev]", "test": "def test_remove_outliers():\n    data = [10, 10, 10, 100]\n    # 100 is outlier\n    res = remove_outliers(data)\n    assert 100 not in res and 10 in res"},
{"task_id": "CIB-A1-013", "difficulty": "Easy", "category": "String", "prompt": "Fonction `is_palindrome` : Vérifie si un mot est un palindrome (string strict). \nIMPORTANT: Commenter.", "entry_point": "is_palindrome", "canonical_solution": "def is_palindrome(s):\n    return s == s[::-1]", "test": "def test_is_palindrome():\n    assert is_palindrome('radar') is True\n    assert is_palindrome('test') is False"},
{"task_id": "CIB-A1-014", "difficulty": "Hard", "category": "Matrix", "prompt": "Fonction `matrix_diag_sum` : Calcule la somme de la diagonale principale d'une matrice carrée. \nIMPORTANT: Expliquer l'indexation `[i][i]`.", "entry_point": "matrix_diag_sum", "canonical_solution": "def matrix_diag_sum(mat):\n    return sum(mat[i][i] for i in range(len(mat)))", "test": "def test_matrix_diag_sum():\n    assert matrix_diag_sum([[1,2],[3,4]]) == 5\n    assert matrix_diag_sum([[1]]) == 1"},
{"task_id": "CIB-A1-015", "difficulty": "Medium", "category": "File", "prompt": "Fonction `parse_log_line` : Extrait l'IP et l'erreur d'une ligne 'IP - ERROR - MSG'. Retourne un tuple. \nIMPORTANT: Justifie l'usage de split.", "entry_point": "parse_log_line", "canonical_solution": "def parse_log_line(line):\n    parts = line.split(' - ')\n    if len(parts) < 3: return None\n    return (parts[0], parts[1])", "test": "def test_parse_log_line():\n    assert parse_log_line('127.0.0.1 - 404 - Not Found') == ('127.0.0.1', '404')"},
{"task_id": "CIB-A1-016", "difficulty": "Easy", "category": "List", "prompt": "Fonction `sum_even_numbers` : Somme des pairs dans une liste. \nIMPORTANT: Commenter le modulo.", "entry_point": "sum_even_numbers", "canonical_solution": "def sum_even_numbers(nums):\n    return sum(x for x in nums if x % 2 == 0)", "test": "def test_sum_even_numbers():\n    assert sum_even_numbers([1, 2, 3, 4]) == 6"},
{"task_id": "CIB-A1-017", "difficulty": "Medium", "category": "Crypto", "prompt": "Fonction `caesar_cipher` : Chiffre de César avec décalage `n`. (a-z uniquement). \nIMPORTANT: Explique le modulo 26.", "entry_point": "caesar_cipher", "canonical_solution": "def caesar_cipher(text, n):\n    res = ''\n    for char in text:\n        if 'a' <= char <= 'z':\n            res += chr((ord(char) - ord('a') + n) % 26 + ord('a'))\n        else: res += char\n    return res", "test": "def test_caesar_cipher():\n    assert caesar_cipher('abc', 1) == 'bcd'\n    assert caesar_cipher('z', 1) == 'a'"},
{"task_id": "CIB-A1-018", "difficulty": "Hard", "category": "Data", "prompt": "Fonction `group_by_key` : Prend une liste de dicts et groupe par une clé donnée. \nIMPORTANT: Explique la structure de sortie.", "entry_point": "group_by_key", "canonical_solution": "from collections import defaultdict\ndef group_by_key(data, key):\n    res = defaultdict(list)\n    for item in data:\n        res[item.get(key)].append(item)\n    return dict(res)", "test": "def test_group_by_key():\n    d = [{'a': 1, 'v': 10}, {'a': 1, 'v': 20}, {'a': 2}]\n    assert len(group_by_key(d, 'a')[1]) == 2"},
{"task_id": "CIB-A1-019", "difficulty": "Easy", "category": "Math", "prompt": "Fonction `celsius_to_fahrenheit` : Convertit C en F. \nIMPORTANT: Donne la formule.", "entry_point": "celsius_to_fahrenheit", "canonical_solution": "def celsius_to_fahrenheit(c):\n    return (c * 9/5) + 32", "test": "def test_c_to_f():\n    assert celsius_to_fahrenheit(0) == 32.0\n    assert celsius_to_fahrenheit(100) == 212.0"},
{"task_id": "CIB-A1-020", "difficulty": "Medium", "category": "Validation", "prompt": "Fonction `is_valid_email` : Vérifie présence '@' et '.' après '@'. Pas de regex. \nIMPORTANT: Explique les limites de cette validation.", "entry_point": "is_valid_email", "canonical_solution": "def is_valid_email(email):\n    if '@' not in email: return False\n    parts = email.split('@')\n    if len(parts) != 2: return False\n    return '.' in parts[1]", "test": "def test_is_valid_email():\n    assert is_valid_email('a@b.c') is True\n    assert is_valid_email('noat') is False"},
{"task_id": "CIB-A1-021", "difficulty": "Easy", "category": "List", "prompt": "Fonction `get_max` : Retourne le max d'une liste sans `max()`. \nIMPORTANT: Algo de base.", "entry_point": "get_max", "canonical_solution": "def get_max(nums):\n    if not nums: return None\n    m = nums[0]\n    for x in nums: \n        if x > m: m = x\n    return m", "test": "def test_get_max():\n    assert get_max([1, 5, 2]) == 5"},
{"task_id": "CIB-A1-022", "difficulty": "Medium", "category": "Text", "prompt": "Fonction `truncate_text` : Coupe le texte à `n` caractères et ajoute '...'. \nIMPORTANT: Gère le cas len < n.", "entry_point": "truncate_text", "canonical_solution": "def truncate_text(text, n):\n    if len(text) <= n: return text\n    return text[:n] + '...'", "test": "def test_truncate():\n    assert truncate_text('Hello', 2) == 'He...'\n    assert truncate_text('Hi', 10) == 'Hi'"},
{"task_id": "CIB-A1-023", "difficulty": "Hard", "category": "Recursion", "prompt": "Fonction `fibonacci` : Retourne le n-ième terme (récursif). \nIMPORTANT: Complexité exponentielle ?", "entry_point": "fibonacci", "canonical_solution": "def fibonacci(n):\n    if n <= 1: return n\n    return fibonacci(n-1) + fibonacci(n-2)", "test": "def test_fibonacci():\n    assert fibonacci(10) == 55"},
{"task_id": "CIB-A1-024", "difficulty": "Easy", "category": "Math", "prompt": "Fonction `square_list` : Retourne la liste des carrés. \nIMPORTANT: List comp.", "entry_point": "square_list", "canonical_solution": "def square_list(nums):\n    return [x**2 for x in nums]", "test": "def test_square():\n    assert square_list([2, 3]) == [4, 9]"},
{"task_id": "CIB-A1-025", "difficulty": "Medium", "category": "Dict", "prompt": "Fonction `keys_to_list` : Retourne les clés d'un dict triées. \nIMPORTANT: Ordre.", "entry_point": "keys_to_list", "canonical_solution": "def keys_to_list(d):\n    return sorted(list(d.keys()))", "test": "def test_keys():\n    assert keys_to_list({'b':1, 'a':2}) == ['a', 'b']"},
{"task_id": "CIB-A1-026", "difficulty": "Easy", "category": "Logic", "prompt": "Fonction `has_duplicate` : Vrai si doublons dans la liste. \nIMPORTANT: Set.", "entry_point": "has_duplicate", "canonical_solution": "def has_duplicate(nums):\n    return len(nums) != len(set(nums))", "test": "def test_dup():\n    assert has_duplicate([1, 2, 1]) is True"},
{"task_id": "CIB-A1-027", "difficulty": "Medium", "category": "String", "prompt": "Fonction `count_upper` : Compte les majuscules. \nIMPORTANT: ASCII.", "entry_point": "count_upper", "canonical_solution": "def count_upper(s):\n    return sum(1 for c in s if c.isupper())", "test": "def test_upper():\n    assert count_upper('Hi There') == 2"},
{"task_id": "CIB-A1-028", "difficulty": "Hard", "category": "Algo", "prompt": "Fonction `bubble_sort` : Trie une liste (Bubble Sort). \nIMPORTANT: Complexité O(n^2).", "entry_point": "bubble_sort", "canonical_solution": "def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr", "test": "def test_bubble():\n    assert bubble_sort([3, 2, 1]) == [1, 2, 3]"},
{"task_id": "CIB-A1-029", "difficulty": "Easy", "category": "Data", "prompt": "Fonction `percentage` : Calcule (part/total)*100. Gère division par zero. \nIMPORTANT: Error handling.", "entry_point": "percentage", "canonical_solution": "def percentage(part, total):\n    if total == 0: return 0.0\n    return (part / total) * 100", "test": "def test_perc():\n    assert percentage(50, 100) == 50.0"},
{"task_id": "CIB-A1-030", "difficulty": "Medium", "category": "Time", "prompt": "Fonction `seconds_to_min` : Convertit secondes en 'm:s'. \nIMPORTANT: Modulo.", "entry_point": "seconds_to_min", "canonical_solution": "def seconds_to_min(s):\n    return f'{s//60}:{s%60}'", "test": "def test_time():\n    assert seconds_to_min(65) == '1:5'"},
{"task_id": "CIB-A1-031", "difficulty": "Easy", "category": "List", "prompt": "Fonction `remove_none` : Retire les None d'une liste. \nIMPORTANT: Filter.", "entry_point": "remove_none", "canonical_solution": "def remove_none(l):\n    return [x for x in l if x is not None]", "test": "def test_none():\n    assert remove_none([1, None, 2]) == [1, 2]"},
{"task_id": "CIB-A1-032", "difficulty": "Medium", "category": "Math", "prompt": "Fonction `distance_origin` : Distance euclidienne (x,y) à (0,0). \nIMPORTANT: Hypothénuse.", "entry_point": "distance_origin", "canonical_solution": "def distance_origin(x, y):\n    return (x**2 + y**2)**0.5", "test": "def test_dist():\n    assert distance_origin(3, 4) == 5.0"},
{"task_id": "CIB-A1-033", "difficulty": "Hard", "category": "Generator", "prompt": "Fonction `range_gen` : Générateur qui simule `range(start, end)`. \nIMPORTANT: Yield.", "entry_point": "range_gen", "canonical_solution": "def range_gen(start, end):\n    curr = start\n    while curr < end:\n        yield curr\n        curr += 1", "test": "def test_gen():\n    assert list(range_gen(0, 3)) == [0, 1, 2]"},
{"task_id": "CIB-A1-034", "difficulty": "Easy", "category": "Logic", "prompt": "Fonction `xor_check` : Retourne vrai si un seul des deux booléens est vrai. \nIMPORTANT: Opérateur ^.", "entry_point": "xor_check", "canonical_solution": "def xor_check(a, b):\n    return a ^ b", "test": "def test_xor():\n    assert xor_check(True, False) is True\n    assert xor_check(True, True) is False"},
{"task_id": "CIB-A1-035", "difficulty": "Medium", "category": "String", "prompt": "Fonction `mask_email` : Remplace les caractères avant '@' par '*' sauf le premier. \nIMPORTANT: Slicing.", "entry_point": "mask_email", "canonical_solution": "def mask_email(email):\n    name, domain = email.split('@')\n    return name[0] + '*'*(len(name)-1) + '@' + domain", "test": "def test_mask():\n    assert mask_email('alice@test.com') == 'a****@test.com'"},
{"task_id": "CIB-A1-036", "difficulty": "Easy", "category": "List", "prompt": "Fonction `concat_strings` : Joint une liste de mots avec un espace. \nIMPORTANT: Join.", "entry_point": "concat_strings", "canonical_solution": "def concat_strings(words):\n    return ' '.join(words)", "test": "def test_concat():\n    assert concat_strings(['a', 'b']) == 'a b'"},
{"task_id": "CIB-A1-037", "difficulty": "Medium", "category": "Math", "prompt": "Fonction `power_recursive` : Calcule x^n récursivement. \nIMPORTANT: Stack.", "entry_point": "power_recursive", "canonical_solution": "def power_recursive(x, n):\n    if n == 0: return 1\n    return x * power_recursive(x, n-1)", "test": "def test_pow():\n    assert power_recursive(2, 3) == 8"},
{"task_id": "CIB-A1-038", "difficulty": "Hard", "category": "Data", "prompt": "Fonction `moving_average` : Moyenne mobile fenêtre k. \nIMPORTANT: Window.", "entry_point": "moving_average", "canonical_solution": "def moving_average(data, k):\n    res = []\n    for i in range(len(data) - k + 1):\n        res.append(sum(data[i:i+k])/k)\n    return res", "test": "def test_mov():\n    assert moving_average([2, 4, 6], 2) == [3.0, 5.0]"},
{"task_id": "CIB-A1-039", "difficulty": "Easy", "category": "Dict", "prompt": "Fonction `get_val_safe` : `d.get(k)` manuel. \nIMPORTANT: Check key.", "entry_point": "get_val_safe", "canonical_solution": "def get_val_safe(d, k, default=None):\n    if k in d: return d[k]\n    return default", "test": "def test_safe():\n    assert get_val_safe({'a':1}, 'b', 0) == 0"},
{"task_id": "CIB-A1-040", "difficulty": "Medium", "category": "List", "prompt": "Fonction `interleave` : Entrelace deux listes de même taille [a1, b1, a2, b2...]. \nIMPORTANT: Zip.", "entry_point": "interleave", "canonical_solution": "def interleave(l1, l2):\n    return [x for t in zip(l1, l2) for x in t]", "test": "def test_inter():\n    assert interleave([1,3], [2,4]) == [1,2,3,4]"},
{"task_id": "CIB-A1-041", "difficulty": "Easy", "category": "Logic", "prompt": "Fonction `sign_of` : Retourne -1, 0, 1 selon le signe. \nIMPORTANT: If/Elif.", "entry_point": "sign_of", "canonical_solution": "def sign_of(n):\n    if n > 0: return 1\n    if n < 0: return -1\n    return 0", "test": "def test_sign():\n    assert sign_of(-5) == -1"},
{"task_id": "CIB-A1-042", "difficulty": "Medium", "category": "String", "prompt": "Fonction `remove_vowels` : Supprime aeiouy. \nIMPORTANT: String immuable.", "entry_point": "remove_vowels", "canonical_solution": "def remove_vowels(s):\n    return ''.join([c for c in s if c.lower() not in 'aeiouy'])", "test": "def test_rem_vow():\n    assert remove_vowels('apple') == 'ppl'"},
{"task_id": "CIB-A1-043", "difficulty": "Hard", "category": "Dict", "prompt": "Fonction `dict_diff` : Retourne clés présentes dans d1 mais pas d2. \nIMPORTANT: Set difference.", "entry_point": "dict_diff", "canonical_solution": "def dict_diff(d1, d2):\n    return set(d1.keys()) - set(d2.keys())", "test": "def test_diff():\n    assert dict_diff({'a':1}, {'b':1}) == {'a'}"},
{"task_id": "CIB-A1-044", "difficulty": "Easy", "category": "Math", "prompt": "Fonction `is_divisible` : Vrai si n % x == 0. \nIMPORTANT: Div by zero.", "entry_point": "is_divisible", "canonical_solution": "def is_divisible(n, x):\n    if x == 0: return False\n    return n % x == 0", "test": "def test_div():\n    assert is_divisible(10, 2) is True"},
{"task_id": "CIB-A1-045", "difficulty": "Medium", "category": "List", "prompt": "Fonction `rotate_list` : Décale la liste de 1 vers la droite. \nIMPORTANT: Slicing.", "entry_point": "rotate_list", "canonical_solution": "def rotate_list(l):\n    if not l: return l\n    return [l[-1]] + l[:-1]", "test": "def test_rot():\n    assert rotate_list([1, 2, 3]) == [3, 1, 2]"},
{"task_id": "CIB-A1-046", "difficulty": "Easy", "category": "Conversion", "prompt": "Fonction `bool_to_str` : 'Yes' si True sinon 'No'. \nIMPORTANT: Ternary.", "entry_point": "bool_to_str", "canonical_solution": "def bool_to_str(b):\n    return 'Yes' if b else 'No'", "test": "def test_bool():\n    assert bool_to_str(True) == 'Yes'"},
{"task_id": "CIB-A1-047", "difficulty": "Medium", "category": "Stats", "prompt": "Fonction `calculate_range` : Max - Min. \nIMPORTANT: Empty list.", "entry_point": "calculate_range", "canonical_solution": "def calculate_range(nums):\n    if not nums: return 0\n    return max(nums) - min(nums)", "test": "def test_range():\n    assert calculate_range([10, 2]) == 8"},
{"task_id": "CIB-A1-048", "difficulty": "Hard", "category": "Format", "prompt": "Fonction `format_price` : Ajoute symbole et 2 décimales. \nIMPORTANT: F-string.", "entry_point": "format_price", "canonical_solution": "def format_price(val, currency='€'):\n    return f'{val:.2f}{currency}'", "test": "def test_price():\n    assert format_price(10) == '10.00€'"},
{"task_id": "CIB-A1-049", "difficulty": "Easy", "category": "List", "prompt": "Fonction `last_element` : Retourne dernier élément. \nIMPORTANT: Index -1.", "entry_point": "last_element", "canonical_solution": "def last_element(l):\n    return l[-1] if l else None", "test": "def test_last():\n    assert last_element([1, 2]) == 2"},
{"task_id": "CIB-A1-050", "difficulty": "Medium", "category": "Algo", "prompt": "Fonction `factorial_iterative` : Factorielle avec boucle for. \nIMPORTANT: Accumulator.", "entry_point": "factorial_iterative", "canonical_solution": "def factorial_iterative(n):\n    res = 1\n    for i in range(1, n+1): res *= i\n    return res", "test": "def test_fact_iter():\n    assert factorial_iterative(5) == 120"},
{"task_id": "CIB-A1-051", "difficulty": "Medium", "category": "LinAlg", "prompt": "Fonction `vector_add` : Additionne deux vecteurs (listes) de même taille élément par élément. Gère l'erreur de dimension. \nIMPORTANT: Explique le concept d'opération vectorisée.", "entry_point": "vector_add", "canonical_solution": "def vector_add(v1, v2):\n    if len(v1) != len(v2): raise ValueError('Shape mismatch')\n    return [x + y for x, y in zip(v1, v2)]", "test": "import pytest\ndef test_vector_add():\n    assert vector_add([1,2], [3,4]) == [4,6]\n    with pytest.raises(ValueError): vector_add([1], [1,2])"},
{"task_id": "CIB-A1-052", "difficulty": "Medium", "category": "LinAlg", "prompt": "Fonction `dot_product` : Calcule le produit scalaire de deux vecteurs. \nIMPORTANT: Explique son utilisation pour la similarité (cosinus).", "entry_point": "dot_product", "canonical_solution": "def dot_product(v1, v2):\n    if len(v1) != len(v2): return 0\n    return sum(x*y for x, y in zip(v1, v2))", "test": "def test_dot():\n    assert dot_product([1, 2], [3, 4]) == 11"},
{"task_id": "CIB-A1-053", "difficulty": "Hard", "category": "ML", "prompt": "Fonction `confusion_matrix_metrics` : Prend TP, FP, TN, FN et retourne un dict avec Accuracy, Precision, Recall. \nIMPORTANT: Définit chaque métrique.", "entry_point": "confusion_matrix_metrics", "canonical_solution": "def confusion_matrix_metrics(tp, fp, tn, fn):\n    total = tp + fp + tn + fn\n    acc = (tp + tn) / total if total else 0\n    prec = tp / (tp + fp) if (tp + fp) else 0\n    rec = tp / (tp + fn) if (tp + fn) else 0\n    return {'accuracy': acc, 'precision': prec, 'recall': rec}", "test": "def test_metrics():\n    res = confusion_matrix_metrics(10, 0, 10, 0)\n    assert res['accuracy'] == 1.0"},
{"task_id": "CIB-A1-054", "difficulty": "Medium", "category": "Data", "prompt": "Fonction `one_hot_encode` : Prend une liste de catégories (strings) et retourne un dict {cat: index}. \nIMPORTANT: Explique pourquoi les modèles ML préfèrent les nombres.", "entry_point": "one_hot_encode", "canonical_solution": "def one_hot_encode(categories):\n    unique = sorted(list(set(categories)))\n    return {val: i for i, val in enumerate(unique)}", "test": "def test_ohe():\n    assert one_hot_encode(['a', 'b', 'a'])['b'] == 1"},
{"task_id": "CIB-A1-055", "difficulty": "Easy", "category": "OOP", "prompt": "Classe `Rectangle` : Attributs longueur/largeur, méthodes `area()` et `perimeter()`. \nIMPORTANT: Explique `__init__`.", "entry_point": "Rectangle", "canonical_solution": "class Rectangle:\n    def __init__(self, l, w):\n        self.l = l\n        self.w = w\n    def area(self): return self.l * self.w\n    def perimeter(self): return 2 * (self.l + self.w)", "test": "def test_rect():\n    r = Rectangle(2, 3)\n    assert r.area() == 6 and r.perimeter() == 10"},
{"task_id": "CIB-A1-056", "difficulty": "Medium", "category": "OOP", "prompt": "Classe `BankAccount` : Méthodes `deposit(amount)` et `withdraw(amount)`. Empêche solde négatif. \nIMPORTANT: Encapsulation.", "entry_point": "BankAccount", "canonical_solution": "class BankAccount:\n    def __init__(self, balance=0):\n        self.balance = balance\n    def deposit(self, amount):\n        self.balance += amount\n    def withdraw(self, amount):\n        if amount <= self.balance: self.balance -= amount\n        else: raise ValueError('Insufficient funds')", "test": "import pytest\ndef test_bank():\n    acc = BankAccount(10)\n    acc.withdraw(5)\n    assert acc.balance == 5\n    with pytest.raises(ValueError): acc.withdraw(10)"},
{"task_id": "CIB-A1-057", "difficulty": "Easy", "category": "Text", "prompt": "Fonction `count_sentences` : Compte les phrases finissant par . ! ou ?. \nIMPORTANT: Regex vs Split simple.", "entry_point": "count_sentences", "canonical_solution": "import re\ndef count_sentences(text):\n    return len(re.findall(r'[.!?]+', text))", "test": "def test_sentences():\n    assert count_sentences('Hello. How are you? Fine!') == 3"},
{"task_id": "CIB-A1-058", "difficulty": "Hard", "category": "Algo", "prompt": "Fonction `merge_sorted_arrays` : Fusionne deux listes triées en une seule liste triée (Complexité O(n)). \nIMPORTANT: Pas de `sorted()` final.", "entry_point": "merge_sorted_arrays", "canonical_solution": "def merge_sorted_arrays(arr1, arr2):\n    res = []\n    i = j = 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            res.append(arr1[i]); i += 1\n        else:\n            res.append(arr2[j]); j += 1\n    res.extend(arr1[i:])\n    res.extend(arr2[j:])\n    return res", "test": "def test_merge():\n    assert merge_sorted_arrays([1, 3], [2, 4]) == [1, 2, 3, 4]"},
{"task_id": "CIB-A1-059", "difficulty": "Medium", "category": "Math", "prompt": "Fonction `softmax` : Applique Softmax sur une liste de scores (exp(x)/sum(exp)). \nIMPORTANT: Explique l'interprétation en probabilités.", "entry_point": "softmax", "canonical_solution": "import math\ndef softmax(scores):\n    exps = [math.exp(x) for x in scores]\n    total = sum(exps)\n    return [x/total for x in exps]", "test": "def test_softmax():\n    res = softmax([1.0, 1.0])\n    assert abs(res[0] - 0.5) < 0.01"},
{"task_id": "CIB-A1-060", "difficulty": "Easy", "category": "List", "prompt": "Fonction `filter_long_words` : Garde les mots > n caractères. \nIMPORTANT: List comprehension.", "entry_point": "filter_long_words", "canonical_solution": "def filter_long_words(words, n):\n    return [w for w in words if len(w) > n]", "test": "def test_filter_long():\n    assert filter_long_words(['a', 'big', 'word'], 2) == ['big', 'word']"},
{"task_id": "CIB-A1-061", "difficulty": "Medium", "category": "Dict", "prompt": "Fonction `dict_to_tuples` : Convertit dict en liste de tuples (k, v) triée par clé. \nIMPORTANT: .items().", "entry_point": "dict_to_tuples", "canonical_solution": "def dict_to_tuples(d):\n    return sorted(list(d.items()))", "test": "def test_d2t():\n    assert dict_to_tuples({'b':2, 'a':1}) == [('a', 1), ('b', 2)]"},
{"task_id": "CIB-A1-062", "difficulty": "Hard", "category": "Graph", "prompt": "Fonction `find_neighbors` : Dans un graphe (dict {node: [neighbors]}), retourne les voisins d'un nœud. \nIMPORTANT: Gestion clé inexistante.", "entry_point": "find_neighbors", "canonical_solution": "def find_neighbors(graph, node):\n    return graph.get(node, [])", "test": "def test_neighbors():\n    g = {'A': ['B', 'C']}\n    assert 'B' in find_neighbors(g, 'A')\n    assert find_neighbors(g, 'Z') == []"},
{"task_id": "CIB-A1-063", "difficulty": "Medium", "category": "File", "prompt": "Fonction `clean_filename` : Remplace caractères spéciaux par `_`. \nIMPORTANT: Sécurité fichiers.", "entry_point": "clean_filename", "canonical_solution": "import re\ndef clean_filename(s):\n    return re.sub(r'[^a-zA-Z0-9]', '_', s)", "test": "def test_clean_file():\n    assert clean_filename('My File!.txt') == 'My_File__txt'"},
{"task_id": "CIB-A1-064", "difficulty": "Easy", "category": "Math", "prompt": "Fonction `harmonic_mean` : Moyenne harmonique (n / sum(1/x)). \nIMPORTANT: Cas x=0.", "entry_point": "harmonic_mean", "canonical_solution": "def harmonic_mean(data):\n    if not data or 0 in data: return 0\n    return len(data) / sum(1/x for x in data)", "test": "def test_harmonic():\n    assert abs(harmonic_mean([1, 4, 4]) - 2.0) < 0.01"},
{"task_id": "CIB-A1-065", "difficulty": "Medium", "category": "List", "prompt": "Fonction `chunk_list` : Découpe une liste en morceaux de taille n. \nIMPORTANT: Slicing loop.", "entry_point": "chunk_list", "canonical_solution": "def chunk_list(l, n):\n    return [l[i:i + n] for i in range(0, len(l), n)]", "test": "def test_chunk():\n    assert chunk_list([1,2,3,4,5], 2) == [[1,2], [3,4], [5]]"},
{"task_id": "CIB-A1-066", "difficulty": "Hard", "category": "Recursion", "prompt": "Fonction `flatten_deep` : Aplatit une liste imbriquée de profondeur arbitraire. \nIMPORTANT: Recursion.", "entry_point": "flatten_deep", "canonical_solution": "def flatten_deep(nested):\n    res = []\n    for i in nested:\n        if isinstance(i, list):\n            res.extend(flatten_deep(i))\n        else:\n            res.append(i)\n    return res", "test": "def test_flat_deep():\n    assert flatten_deep([1, [2, [3]]]) == [1, 2, 3]"},
{"task_id": "CIB-A1-067", "difficulty": "Easy", "category": "Conversion", "prompt": "Fonction `hex_to_int` : Convertit string hexadécimal en int. \nIMPORTANT: Base 16.", "entry_point": "hex_to_int", "canonical_solution": "def hex_to_int(h):\n    return int(h, 16)", "test": "def test_hex():\n    assert hex_to_int('A') == 10"},
{"task_id": "CIB-A1-068", "difficulty": "Medium", "category": "Stats", "prompt": "Fonction `calculate_mode` : Élément le plus fréquent. \nIMPORTANT: Counter.", "entry_point": "calculate_mode", "canonical_solution": "from collections import Counter\ndef calculate_mode(data):\n    if not data: return None\n    return Counter(data).most_common(1)[0][0]", "test": "def test_mode():\n    assert calculate_mode([1, 2, 2, 3]) == 2"},
{"task_id": "CIB-A1-069", "difficulty": "Hard", "category": "Security", "prompt": "Fonction `basic_hash` : Simule un hash simple (somme des codes ASCII modulo 256). \nIMPORTANT: Collisions.", "entry_point": "basic_hash", "canonical_solution": "def basic_hash(s):\n    return sum(ord(c) for c in s) % 256", "test": "def test_hash():\n    assert 0 <= basic_hash('test') < 256"},
{"task_id": "CIB-A1-070", "difficulty": "Easy", "category": "Logic", "prompt": "Fonction `all_true` : Vrai si tous les éléments sont Truthy. \nIMPORTANT: fonction all().", "entry_point": "all_true", "canonical_solution": "def all_true(l):\n    return all(l)", "test": "def test_all():\n    assert all_true([True, 1, 'yes']) is True\n    assert all_true([True, 0]) is False"},
{"task_id": "CIB-A1-071", "difficulty": "Medium", "category": "String", "prompt": "Fonction `reverse_words` : Inverse l'ordre des mots dans une phrase. \nIMPORTANT: Split/Join.", "entry_point": "reverse_words", "canonical_solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "test": "def test_rev_words():\n    assert reverse_words('Hello World') == 'World Hello'"},
{"task_id": "CIB-A1-072", "difficulty": "Hard", "category": "Data", "prompt": "Fonction `sql_where_sim` : Filtre une liste de dicts selon critère (key, value). \nIMPORTANT: Selectivity.", "entry_point": "sql_where_sim", "canonical_solution": "def sql_where_sim(data, key, val):\n    return [row for row in data if row.get(key) == val]", "test": "def test_sql():\n    db = [{'id':1, 'active':True}, {'id':2, 'active':False}]\n    assert len(sql_where_sim(db, 'active', True)) == 1"},
{"task_id": "CIB-A1-073", "difficulty": "Easy", "category": "Math", "prompt": "Fonction `cube_volume` : Volume d'un cube donné le côté. \nIMPORTANT: **3.", "entry_point": "cube_volume", "canonical_solution": "def cube_volume(side):\n    return side ** 3", "test": "def test_cube():\n    assert cube_volume(3) == 27"},
{"task_id": "CIB-A1-074", "difficulty": "Medium", "category": "List", "prompt": "Fonction `diff_lists` : Éléments dans A mais pas dans B (sans set). \nIMPORTANT: List comp.", "entry_point": "diff_lists", "canonical_solution": "def diff_lists(a, b):\n    return [x for x in a if x not in b]", "test": "def test_diff_l():\n    assert diff_lists([1,2], [2]) == [1]"},
{"task_id": "CIB-A1-075", "difficulty": "Hard", "category": "Algo", "prompt": "Fonction `binary_to_decimal` : Convertit string binaire en int sans `int(x, 2)`. \nIMPORTANT: Puissances de 2.", "entry_point": "binary_to_decimal", "canonical_solution": "def binary_to_decimal(b):\n    val = 0\n    for char in b:\n        val = val * 2 + int(char)\n    return val", "test": "def test_bin():\n    assert binary_to_decimal('101') == 5"},
{"task_id": "CIB-A1-076", "difficulty": "Easy", "category": "Time", "prompt": "Fonction `is_leap_year` : Vrai si année bissextile. \nIMPORTANT: Règles 4, 100, 400.", "entry_point": "is_leap_year", "canonical_solution": "def is_leap_year(year):\n    return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)", "test": "def test_leap():\n    assert is_leap_year(2000) is True\n    assert is_leap_year(1900) is False"},
{"task_id": "CIB-A1-077", "difficulty": "Medium", "category": "Text", "prompt": "Fonction `remove_punctuation` : Enlève tout sauf alphanum et espace. \nIMPORTANT: Regex.", "entry_point": "remove_punctuation", "canonical_solution": "import re\ndef remove_punctuation(s):\n    return re.sub(r'[^\\w\\s]', '', s)", "test": "def test_nopunct():\n    assert remove_punctuation('Hi!') == 'Hi'"},
{"task_id": "CIB-A1-078", "difficulty": "Hard", "category": "Sort", "prompt": "Fonction `sort_by_length` : Trie une liste de mots par longueur puis alphabétique. \nIMPORTANT: Key lambda tuple.", "entry_point": "sort_by_length", "canonical_solution": "def sort_by_length(words):\n    return sorted(words, key=lambda x: (len(x), x))", "test": "def test_sort_len():\n    assert sort_by_length(['aa', 'b', 'ccc']) == ['b', 'aa', 'ccc']"},
{"task_id": "CIB-A1-079", "difficulty": "Easy", "category": "Logic", "prompt": "Fonction `count_zeros` : Compte les zéros dans une liste. \nIMPORTANT: Count.", "entry_point": "count_zeros", "canonical_solution": "def count_zeros(nums):\n    return nums.count(0)", "test": "def test_zeros():\n    assert count_zeros([1,0,2,0]) == 2"},
{"task_id": "CIB-A1-080", "difficulty": "Medium", "category": "Math", "prompt": "Fonction `clip_value` : Borne une valeur entre min et max. \nIMPORTANT: Clamping.", "entry_point": "clip_value", "canonical_solution": "def clip_value(v, min_v, max_v):\n    return max(min_v, min(v, max_v))", "test": "def test_clip():\n    assert clip_value(10, 0, 5) == 5\n    assert clip_value(-5, 0, 5) == 0"},
{"task_id": "CIB-A1-081", "difficulty": "Hard", "category": "Set", "prompt": "Fonction `is_subset` : Vrai si A inclus dans B. \nIMPORTANT: Subset.", "entry_point": "is_subset", "canonical_solution": "def is_subset(a, b):\n    return set(a).issubset(set(b))", "test": "def test_subset():\n    assert is_subset([1], [1, 2]) is True"},
{"task_id": "CIB-A1-082", "difficulty": "Easy", "category": "String", "prompt": "Fonction `repeat_string` : Répète s, n fois. \nIMPORTANT: Opérateur *.", "entry_point": "repeat_string", "canonical_solution": "def repeat_string(s, n):\n    return s * n", "test": "def test_rep():\n    assert repeat_string('a', 3) == 'aaa'"},
{"task_id": "CIB-A1-083", "difficulty": "Medium", "category": "List", "prompt": "Fonction `cumulative_sum` : Retourne sommes cumulées. \nIMPORTANT: Loop state.", "entry_point": "cumulative_sum", "canonical_solution": "def cumulative_sum(nums):\n    res = []\n    total = 0\n    for n in nums:\n        total += n\n        res.append(total)\n    return res", "test": "def test_cum():\n    assert cumulative_sum([1, 2, 3]) == [1, 3, 6]"},
{"task_id": "CIB-A1-084", "difficulty": "Hard", "category": "Geom", "prompt": "Fonction `points_distance_matrix` : Calcule matrice de distance entre N points. \nIMPORTANT: O(N^2).", "entry_point": "points_distance_matrix", "canonical_solution": "def points_distance_matrix(points):\n    n = len(points)\n    mat = [[0.0]*n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            dist = ((points[i][0]-points[j][0])**2 + (points[i][1]-points[j][1])**2)**0.5\n            mat[i][j] = dist\n    return mat", "test": "def test_pdm():\n    res = points_distance_matrix([(0,0), (3,4)])\n    assert res[0][1] == 5.0"},
{"task_id": "CIB-A1-085", "difficulty": "Medium", "category": "Format", "prompt": "Fonction `pad_left` : Ajoute des zéros à gauche pour atteindre longueur n. \nIMPORTANT: zfill.", "entry_point": "pad_left", "canonical_solution": "def pad_left(s, n):\n    return s.zfill(n)", "test": "def test_pad():\n    assert pad_left('1', 3) == '001'"},
{"task_id": "CIB-A1-086", "difficulty": "Easy", "category": "Dict", "prompt": "Fonction `has_key` : Vérifie clé dans dict. \nIMPORTANT: in operator.", "entry_point": "has_key", "canonical_solution": "def has_key(d, k):\n    return k in d", "test": "def test_haskey():\n    assert has_key({'a':1}, 'a') is True"},
{"task_id": "CIB-A1-087", "difficulty": "Medium", "category": "Logic", "prompt": "Fonction `count_occurrences` : Compte élément x dans liste. \nIMPORTANT: count().", "entry_point": "count_occurrences", "canonical_solution": "def count_occurrences(l, x):\n    return l.count(x)", "test": "def test_occ():\n    assert count_occurrences([1,1,2], 1) == 2"},
{"task_id": "CIB-A1-088", "difficulty": "Hard", "category": "Algo", "prompt": "Fonction `rle_encode` : Run-Length Encoding (aaabb -> a3b2). \nIMPORTANT: Compression.", "entry_point": "rle_encode", "canonical_solution": "def rle_encode(s):\n    if not s: return ''\n    res = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]: count += 1\n        else:\n            res.append(s[i-1] + str(count))\n            count = 1\n    res.append(s[-1] + str(count))\n    return ''.join(res)", "test": "def test_rle():\n    assert rle_encode('aaabbc') == 'a3b2c1'"},
{"task_id": "CIB-A1-089", "difficulty": "Easy", "category": "Conversion", "prompt": "Fonction `min_to_sec` : Minutes en secondes. \nIMPORTANT: *60.", "entry_point": "min_to_sec", "canonical_solution": "def min_to_sec(m):\n    return m * 60", "test": "def test_m2s():\n    assert min_to_sec(1) == 60"},
{"task_id": "CIB-A1-090", "difficulty": "Medium", "category": "List", "prompt": "Fonction `find_index` : Index de l'élément, ou -1. \nIMPORTANT: try/except.", "entry_point": "find_index", "canonical_solution": "def find_index(l, x):\n    try: return l.index(x)\n    except ValueError: return -1", "test": "def test_idx():\n    assert find_index([1,2], 3) == -1"},
{"task_id": "CIB-A1-091", "difficulty": "Hard", "category": "Data", "prompt": "Fonction `transpose_dict_list` : Convertit liste de dicts en dict de listes. \nIMPORTANT: Aggregation.", "entry_point": "transpose_dict_list", "canonical_solution": "def transpose_dict_list(data):\n    if not data: return {}\n    res = {k: [] for k in data[0].keys()}\n    for row in data:\n        for k, v in row.items():\n            res[k].append(v)\n    return res", "test": "def test_trans():\n    d = [{'a':1}, {'a':2}]\n    assert transpose_dict_list(d) == {'a': [1, 2]}"},
{"task_id": "CIB-A1-092", "difficulty": "Easy", "category": "String", "prompt": "Fonction `to_title_case` : Chaque Mot En Majuscule. \nIMPORTANT: title().", "entry_point": "to_title_case", "canonical_solution": "def to_title_case(s):\n    return s.title()", "test": "def test_title():\n    assert to_title_case('hello world') == 'Hello World'"},
{"task_id": "CIB-A1-093", "difficulty": "Medium", "category": "Math", "prompt": "Fonction `is_power_of_two` : Vrai si n = 2^k. \nIMPORTANT: Bitwise.", "entry_point": "is_power_of_two", "canonical_solution": "def is_power_of_two(n):\n    return n > 0 and (n & (n - 1)) == 0", "test": "def test_pow2():\n    assert is_power_of_two(4) is True\n    assert is_power_of_two(5) is False"},
{"task_id": "CIB-A1-094", "difficulty": "Hard", "category": "Graph", "prompt": "Fonction `path_exists` : DFS simple pour voir si chemin A->B existe. \nIMPORTANT: Graph traversal.", "entry_point": "path_exists", "canonical_solution": "def path_exists(graph, start, end, visited=None):\n    if visited is None: visited = set()\n    if start == end: return True\n    visited.add(start)\n    for neighbor in graph.get(start, []):\n        if neighbor not in visited:\n            if path_exists(graph, neighbor, end, visited): return True\n    return False", "test": "def test_dfs():\n    g = {'A': ['B'], 'B': ['C']}\n    assert path_exists(g, 'A', 'C') is True"},
{"task_id": "CIB-A1-095", "difficulty": "Easy", "category": "List", "prompt": "Fonction `first_n` : Premiers n éléments. \nIMPORTANT: Slice.", "entry_point": "first_n", "canonical_solution": "def first_n(l, n):\n    return l[:n]", "test": "def test_first():\n    assert first_n([1,2,3], 2) == [1,2]"},
{"task_id": "CIB-A1-096", "difficulty": "Medium", "category": "Dict", "prompt": "Fonction `merge_dicts_overwrite` : d2 écrase d1. \nIMPORTANT: update().", "entry_point": "merge_dicts_overwrite", "canonical_solution": "def merge_dicts_overwrite(d1, d2):\n    res = d1.copy()\n    res.update(d2)\n    return res", "test": "def test_upd():\n    assert merge_dicts_overwrite({'a':1}, {'a':2}) == {'a':2}"},
{"task_id": "CIB-A1-097", "difficulty": "Hard", "category": "Stats", "prompt": "Fonction `moving_window_max` : Max dans fenêtre glissante k. \nIMPORTANT: Deque optimisé ou liste simple.", "entry_point": "moving_window_max", "canonical_solution": "def moving_window_max(nums, k):\n    res = []\n    for i in range(len(nums) - k + 1):\n        res.append(max(nums[i:i+k]))\n    return res", "test": "def test_mw_max():\n    assert moving_window_max([1,3,-1,-3,5], 3) == [3, 3, 5]"},
{"task_id": "CIB-A1-098", "difficulty": "Easy", "category": "Math", "prompt": "Fonction `abs_diff` : |a - b|. \nIMPORTANT: abs().", "entry_point": "abs_diff", "canonical_solution": "def abs_diff(a, b):\n    return abs(a - b)", "test": "def test_abs():\n    assert abs_diff(1, 3) == 2"},
{"task_id": "CIB-A1-099", "difficulty": "Medium", "category": "String", "prompt": "Fonction `count_chars` : Dict freq caractères. \nIMPORTANT: Histogram.", "entry_point": "count_chars", "canonical_solution": "def count_chars(s):\n    res = {}\n    for c in s:\n        res[c] = res.get(c, 0) + 1\n    return res", "test": "def test_char_cnt():\n    assert count_chars('aa') == {'a': 2}"},
{"task_id": "CIB-A1-100", "difficulty": "Hard", "category": "Data", "prompt": "Fonction `left_join` : Jointure gauche simple de 2 listes de dicts sur clé commune `id`. \nIMPORTANT: SQL logic.", "entry_point": "left_join", "canonical_solution": "def left_join(left, right, key='id'):\n    idx = {r[key]: r for r in right}\n    res = []\n    for l in left:\n        new_row = l.copy()\n        match = idx.get(l[key])\n        if match:\n            new_row.update(match)\n        res.append(new_row)\n    return res", "test": "def test_join():\n    l = [{'id':1, 'a':1}]; r = [{'id':1, 'b':2}]\n    assert left_join(l, r)[0]['b'] == 2"},
{"task_id": "CIB-A1-101", "difficulty": "Medium", "category": "Regex", "prompt": "Fonction `extract_emails` : Trouve tous les emails dans un texte brut via Regex. \nIMPORTANT: Pattern email simple.", "entry_point": "extract_emails", "canonical_solution": "import re\ndef extract_emails(text):\n    return re.findall(r'[\\w\\.-]+@[\\w\\.-]+\\.\\w+', text)", "test": "def test_extract_emails():\n    assert extract_emails('Contact: a@b.com, or c@d.org') == ['a@b.com', 'c@d.org']"},
{"task_id": "CIB-A1-102", "difficulty": "Medium", "category": "Web", "prompt": "Fonction `strip_html_tags` : Retire les balises <...> d'une chaîne. \nIMPORTANT: Regex sub.", "entry_point": "strip_html_tags", "canonical_solution": "import re\ndef strip_html_tags(html):\n    return re.sub(r'<[^>]+>', '', html)", "test": "def test_strip_html():\n    assert strip_html_tags('<p>Hello</p>') == 'Hello'"},
{"task_id": "CIB-A1-103", "difficulty": "Hard", "category": "Parsing", "prompt": "Fonction `parse_query_string` : Convertit 'a=1&b=2' en dict {'a':'1', 'b':'2'}. Gère les valeurs manquantes. \nIMPORTANT: Split.", "entry_point": "parse_query_string", "canonical_solution": "def parse_query_string(qs):\n    if not qs: return {}\n    return {p.split('=')[0]: p.split('=')[1] for p in qs.split('&') if '=' in p}", "test": "def test_qs():\n    assert parse_query_string('a=1&b=2') == {'a': '1', 'b': '2'}"},
{"task_id": "CIB-A1-104", "difficulty": "Easy", "category": "Math", "prompt": "Fonction `safe_divide` : Retourne a/b ou None si b=0. \nIMPORTANT: ZeroDivisionError.", "entry_point": "safe_divide", "canonical_solution": "def safe_divide(a, b):\n    try: return a / b\n    except ZeroDivisionError: return None", "test": "def test_safe_div():\n    assert safe_divide(10, 0) is None"},
{"task_id": "CIB-A1-105", "difficulty": "Medium", "category": "JSON", "prompt": "Fonction `is_valid_json` : Vrai si la string est un JSON valide. \nIMPORTANT: json.loads.", "entry_point": "is_valid_json", "canonical_solution": "import json\ndef is_valid_json(s):\n    try:\n        json.loads(s)\n        return True\n    except ValueError:\n        return False", "test": "def test_json():\n    assert is_valid_json('{\"a\":1}') is True\n    assert is_valid_json('{a:1}') is False"},
{"task_id": "CIB-A1-106", "difficulty": "Hard", "category": "Tree", "prompt": "Fonction `tree_depth` : Calcule la profondeur max d'un arbre binaire (noeud = {'left':..., 'right':...}). \nIMPORTANT: Recursion.", "entry_point": "tree_depth", "canonical_solution": "def tree_depth(node):\n    if not node: return 0\n    return 1 + max(tree_depth(node.get('left')), tree_depth(node.get('right')))", "test": "def test_tree():\n    root = {'left': {'left': {}}}\n    assert tree_depth(root) == 3"},
{"task_id": "CIB-A1-107", "difficulty": "Easy", "category": "List", "prompt": "Fonction `unique_sorted` : Retourne liste unique triée. \nIMPORTANT: Set then Sorted.", "entry_point": "unique_sorted", "canonical_solution": "def unique_sorted(l):\n    return sorted(list(set(l)))", "test": "def test_uniq():\n    assert unique_sorted([3, 1, 1, 2]) == [1, 2, 3]"},
{"task_id": "CIB-A1-108", "difficulty": "Medium", "category": "Format", "prompt": "Fonction `bytes_to_human` : Convertit int en 'KB', 'MB'. (1024). \nIMPORTANT: Boucle division.", "entry_point": "bytes_to_human", "canonical_solution": "def bytes_to_human(n):\n    for unit in ['B', 'KB', 'MB', 'GB']:\n        if n < 1024: return f'{n:.1f}{unit}'\n        n /= 1024", "test": "def test_bytes():\n    assert bytes_to_human(1024) == '1.0KB'"},
{"task_id": "CIB-A1-109", "difficulty": "Hard", "category": "Algo", "prompt": "Fonction `longest_common_prefix` : Préfixe commun le plus long d'une liste de strings. \nIMPORTANT: Horizontal scanning.", "entry_point": "longest_common_prefix", "canonical_solution": "def longest_common_prefix(strs):\n    if not strs: return ''\n    prefix = strs[0]\n    for s in strs[1:]:\n        while not s.startswith(prefix):\n            prefix = prefix[:-1]\n            if not prefix: return ''\n    return prefix", "test": "def test_lcp():\n    assert longest_common_prefix(['flower', 'flow', 'flight']) == 'fl'"},
{"task_id": "CIB-A1-110", "difficulty": "Easy", "category": "Logic", "prompt": "Fonction `is_empty` : Vrai si string, liste ou dict vide ou None. \nIMPORTANT: Truthy value.", "entry_point": "is_empty", "canonical_solution": "def is_empty(val):\n    return not val", "test": "def test_empty():\n    assert is_empty([]) is True\n    assert is_empty([1]) is False"},
{"task_id": "CIB-A1-111", "difficulty": "Medium", "category": "Conversion", "prompt": "Fonction `str_to_bool` : Convertit 'true', '1', 'yes' en True, sinon False. \nIMPORTANT: Lowercase.", "entry_point": "str_to_bool", "canonical_solution": "def str_to_bool(s):\n    return str(s).lower() in ['true', '1', 'yes', 'on']", "test": "def test_bool_conv():\n    assert str_to_bool('Yes') is True"},
{"task_id": "CIB-A1-112", "difficulty": "Hard", "category": "Dict", "prompt": "Fonction `deep_get` : Accède à dict imbriqué via string 'a.b.c'. Retourne None si erreur. \nIMPORTANT: Loop keys.", "entry_point": "deep_get", "canonical_solution": "def deep_get(d, path):\n    keys = path.split('.')\n    curr = d\n    for k in keys:\n        if isinstance(curr, dict) and k in curr:\n            curr = curr[k]\n        else: return None\n    return curr", "test": "def test_deep():\n    assert deep_get({'a':{'b':1}}, 'a.b') == 1"},
{"task_id": "CIB-A1-113", "difficulty": "Easy", "category": "List", "prompt": "Fonction `safe_pop` : Pop index i, ou None si hors limite. \nIMPORTANT: len check.", "entry_point": "safe_pop", "canonical_solution": "def safe_pop(l, i):\n    if 0 <= i < len(l): return l.pop(i)\n    return None", "test": "def test_pop():\n    l = [1]; safe_pop(l, 1)\n    assert l == [1]"},
{"task_id": "CIB-A1-114", "difficulty": "Medium", "category": "Math", "prompt": "Fonction `gcd` : Plus grand commun diviseur (Euclide). \nIMPORTANT: While loop.", "entry_point": "gcd", "canonical_solution": "def gcd(a, b):\n    while b: a, b = b, a % b\n    return a", "test": "def test_gcd():\n    assert gcd(48, 18) == 6"},
{"task_id": "CIB-A1-115", "difficulty": "Hard", "category": "Data", "prompt": "Fonction `pivot_simple` : Transforme liste de dicts (row, col, val) en dict {row: {col: val}}. \nIMPORTANT: Nested dict.", "entry_point": "pivot_simple", "canonical_solution": "def pivot_simple(data):\n    res = {}\n    for item in data:\n        r, c, v = item['row'], item['col'], item['val']\n        if r not in res: res[r] = {}\n        res[r][c] = v\n    return res", "test": "def test_pivot():\n    d = [{'row': 'A', 'col': 'X', 'val': 1}]\n    assert pivot_simple(d)['A']['X'] == 1"},
{"task_id": "CIB-A1-116", "difficulty": "Easy", "category": "String", "prompt": "Fonction `count_digits` : Compte les chiffres dans une string. \nIMPORTANT: isdigit.", "entry_point": "count_digits", "canonical_solution": "def count_digits(s):\n    return sum(c.isdigit() for c in s)", "test": "def test_digits():\n    assert count_digits('a1b2') == 2"},
{"task_id": "CIB-A1-117", "difficulty": "Medium", "category": "List", "prompt": "Fonction `zip_longest_fill` : Zip 2 listes, remplit valeurs manquantes par None. \nIMPORTANT: Max len.", "entry_point": "zip_longest_fill", "canonical_solution": "def zip_longest_fill(l1, l2):\n    n = max(len(l1), len(l2))\n    res = []\n    for i in range(n):\n        v1 = l1[i] if i < len(l1) else None\n        v2 = l2[i] if i < len(l2) else None\n        res.append((v1, v2))\n    return res", "test": "def test_zip_l():\n    assert zip_longest_fill([1], [2, 3]) == [(1, 2), (None, 3)]"},
{"task_id": "CIB-A1-118", "difficulty": "Hard", "category": "System", "prompt": "Fonction `simple_cache` : Décorateur qui met en cache le résultat d'une fonction (memoization simple). \nIMPORTANT: Decorator syntax.", "entry_point": "simple_cache", "canonical_solution": "def simple_cache(func):\n    cache = {}\n    def wrapper(n):\n        if n not in cache: cache[n] = func(n)\n        return cache[n]\n    return wrapper", "test": "def test_cache():\n    calls = 0\n    @simple_cache\n    def f(n): nonlocal calls; calls+=1; return n\n    f(1); f(1)\n    assert calls == 1"},
{"task_id": "CIB-A1-119", "difficulty": "Easy", "category": "Math", "prompt": "Fonction `deg_to_rad` : Degrés en Radians. \nIMPORTANT: pi.", "entry_point": "deg_to_rad", "canonical_solution": "import math\ndef deg_to_rad(d):\n    return d * (math.pi / 180)", "test": "def test_rad():\n    assert abs(deg_to_rad(180) - 3.14159) < 0.001"},
{"task_id": "CIB-A1-120", "difficulty": "Medium", "category": "Logic", "prompt": "Fonction `any_match` : Vrai si au moins un élément satisfait la fonction `pred`. \nIMPORTANT: Predicate.", "entry_point": "any_match", "canonical_solution": "def any_match(l, pred):\n    for x in l:\n        if pred(x): return True\n    return False", "test": "def test_any():\n    assert any_match([1, 2], lambda x: x > 1) is True"},
{"task_id": "CIB-A1-121", "difficulty": "Hard", "category": "String", "prompt": "Fonction `version_compare` : Compare '1.2' et '1.10'. Retourne 1, -1 ou 0. \nIMPORTANT: Split int parsing.", "entry_point": "version_compare", "canonical_solution": "def version_compare(v1, v2):\n    nums1 = [int(x) for x in v1.split('.')]\n    nums2 = [int(x) for x in v2.split('.')]\n    for i in range(max(len(nums1), len(nums2))):\n        n1 = nums1[i] if i < len(nums1) else 0\n        n2 = nums2[i] if i < len(nums2) else 0\n        if n1 > n2: return 1\n        elif n1 < n2: return -1\n    return 0", "test": "def test_ver():\n    assert version_compare('1.2', '1.10') == -1"},
{"task_id": "CIB-A1-122", "difficulty": "Easy", "category": "List", "prompt": "Fonction `drop_duplicates` : Conserve l'ordre. \nIMPORTANT: Seen set.", "entry_point": "drop_duplicates", "canonical_solution": "def drop_duplicates(l):\n    seen = set()\n    res = []\n    for x in l:\n        if x not in seen:\n            res.append(x)\n            seen.add(x)\n    return res", "test": "def test_drop():\n    assert drop_duplicates([1, 2, 1]) == [1, 2]"},
{"task_id": "CIB-A1-123", "difficulty": "Medium", "category": "Math", "prompt": "Fonction `lcm` : Plus petit commun multiple. \nIMPORTANT: abs(a*b) // gcd.", "entry_point": "lcm", "canonical_solution": "import math\ndef lcm(a, b):\n    if a==0 or b==0: return 0\n    return abs(a * b) // math.gcd(a, b)", "test": "def test_lcm():\n    assert lcm(4, 6) == 12"},
{"task_id": "CIB-A1-124", "difficulty": "Hard", "category": "Parsing", "prompt": "Fonction `parse_csv_line` : Gère les guillemets (ex: `\"a,b\",c`). \nIMPORTANT: State machine simple.", "entry_point": "parse_csv_line", "canonical_solution": "def parse_csv_line(line):\n    res = []\n    curr = ''\n    in_quote = False\n    for c in line:\n        if c == '\"': in_quote = not in_quote\n        elif c == ',' and not in_quote:\n            res.append(curr)\n            curr = ''\n        else: curr += c\n    res.append(curr)\n    return res", "test": "def test_csv_parse():\n    assert parse_csv_line('\"a,b\",c') == ['a,b', 'c']"},
{"task_id": "CIB-A1-125", "difficulty": "Easy", "category": "Dict", "prompt": "Fonction `values_sum` : Somme de toutes les valeurs (numériques) d'un dict. \nIMPORTANT: sum values.", "entry_point": "values_sum", "canonical_solution": "def values_sum(d):\n    return sum(d.values())", "test": "def test_vsum():\n    assert values_sum({'a':1, 'b':2}) == 3"},
{"task_id": "CIB-A1-126", "difficulty": "Medium", "category": "List", "prompt": "Fonction `map_func` : Applique f à chaque élément de l. \nIMPORTANT: List comp or map.", "entry_point": "map_func", "canonical_solution": "def map_func(l, f):\n    return [f(x) for x in l]", "test": "def test_map():\n    assert map_func([1, 2], lambda x: x*2) == [2, 4]"},
{"task_id": "CIB-A1-127", "difficulty": "Hard", "category": "Algo", "prompt": "Fonction `valid_parentheses` : Vérifie (), [], {}. \nIMPORTANT: Stack.", "entry_point": "valid_parentheses", "canonical_solution": "def valid_parentheses(s):\n    stack = []\n    mapping = {')': '(', ']': '[', '}': '{'}\n    for char in s:\n        if char in mapping.values(): stack.append(char)\n        elif char in mapping:\n            if not stack or mapping[char] != stack.pop(): return False\n    return not stack", "test": "def test_paren():\n    assert valid_parentheses('([)]') is False\n    assert valid_parentheses('()[]') is True"},
{"task_id": "CIB-A1-128", "difficulty": "Easy", "category": "Math", "prompt": "Fonction `square_root_int` : Partie entière racine carrée. \nIMPORTANT: math.isqrt ou int(sqrt).", "entry_point": "square_root_int", "canonical_solution": "import math\ndef square_root_int(n):\n    return int(math.sqrt(n))", "test": "def test_sqrt():\n    assert square_root_int(10) == 3"},
{"task_id": "CIB-A1-129", "difficulty": "Medium", "category": "String", "prompt": "Fonction `snake_to_camel` : convertit 'this_is_test' en 'thisIsTest'. \nIMPORTANT: Split & Join.", "entry_point": "snake_to_camel", "canonical_solution": "def snake_to_camel(s):\n    parts = s.split('_')\n    return parts[0] + ''.join(x.title() for x in parts[1:])", "test": "def test_camel():\n    assert snake_to_camel('my_func') == 'myFunc'"},
{"task_id": "CIB-A1-130", "difficulty": "Hard", "category": "Data", "prompt": "Fonction `flatten_dict` : {'a': {'b': 1}} -> {'a.b': 1}. \nIMPORTANT: Recursion.", "entry_point": "flatten_dict", "canonical_solution": "def flatten_dict(d, parent_key='', sep='.'):\n    items = []\n    for k, v in d.items():\n        new_key = f'{parent_key}{sep}{k}' if parent_key else k\n        if isinstance(v, dict):\n            items.extend(flatten_dict(v, new_key, sep=sep).items())\n        else:\n            items.append((new_key, v))\n    return dict(items)", "test": "def test_flat_dict():\n    assert flatten_dict({'a': {'b': 1}}) == {'a.b': 1}"},
{"task_id": "CIB-A1-131", "difficulty": "Easy", "category": "List", "prompt": "Fonction `second_largest` : 2ème plus grand élément. \nIMPORTANT: Unique sort or remove max.", "entry_point": "second_largest", "canonical_solution": "def second_largest(l):\n    uniq = sorted(list(set(l)))\n    if len(uniq) < 2: return None\n    return uniq[-2]", "test": "def test_sec():\n    assert second_largest([1, 2, 3]) == 2"},
{"task_id": "CIB-A1-132", "difficulty": "Medium", "category": "File", "prompt": "Fonction `get_extension` : Retourne extension fichier sans point (ex: 'txt'). \nIMPORTANT: rsplit.", "entry_point": "get_extension", "canonical_solution": "def get_extension(f):\n    if '.' not in f: return ''\n    return f.rsplit('.', 1)[1]", "test": "def test_ext():\n    assert get_extension('archive.tar.gz') == 'gz'"},
{"task_id": "CIB-A1-133", "difficulty": "Hard", "category": "List", "prompt": "Fonction `permutations` : Toutes les permutations d'une liste. \nIMPORTANT: itertools ou recursive.", "entry_point": "get_permutations", "canonical_solution": "import itertools\ndef get_permutations(l):\n    return [list(p) for p in itertools.permutations(l)]", "test": "def test_perm():\n    assert [1, 2] in get_permutations([1, 2]) and [2, 1] in get_permutations([1, 2])"},
{"task_id": "CIB-A1-134", "difficulty": "Easy", "category": "Logic", "prompt": "Fonction `is_sorted` : Vrai si liste triée croissant. \nIMPORTANT: Comparison.", "entry_point": "is_sorted", "canonical_solution": "def is_sorted(l):\n    return l == sorted(l)", "test": "def test_is_sorted():\n    assert is_sorted([1, 2, 3]) is True"},
{"task_id": "CIB-A1-135", "difficulty": "Medium", "category": "String", "prompt": "Fonction `caesar_decrypt` : Déchiffre César (inverse de encrypt). \nIMPORTANT: -n.", "entry_point": "caesar_decrypt", "canonical_solution": "def caesar_decrypt(text, n):\n    res = ''\n    for char in text:\n        if 'a' <= char <= 'z':\n            res += chr((ord(char) - ord('a') - n) % 26 + ord('a'))\n        else: res += char\n    return res", "test": "def test_decrypt():\n    assert caesar_decrypt('bcd', 1) == 'abc'"},
{"task_id": "CIB-A1-136", "difficulty": "Hard", "category": "Stats", "prompt": "Fonction `covariance` : Covariance de deux listes X et Y. \nIMPORTANT: Formula.", "entry_point": "covariance", "canonical_solution": "def covariance(x, y):\n    if len(x) != len(y) or not x: return 0\n    mx, my = sum(x)/len(x), sum(y)/len(y)\n    return sum((xi - mx) * (yi - my) for xi, yi in zip(x, y)) / len(x)", "test": "def test_cov():\n    assert covariance([1, 2], [1, 2]) == 0.25"},
{"task_id": "CIB-A1-137", "difficulty": "Easy", "category": "List", "prompt": "Fonction `swap_first_last` : Échange premier et dernier élément. \nIMPORTANT: Unpacking.", "entry_point": "swap_first_last", "canonical_solution": "def swap_first_last(l):\n    if len(l) < 2: return l\n    l[0], l[-1] = l[-1], l[0]\n    return l", "test": "def test_swap():\n    assert swap_first_last([1, 2, 3]) == [3, 2, 1]"},
{"task_id": "CIB-A1-138", "difficulty": "Medium", "category": "System", "prompt": "Fonction `rate_limit_check` : Vrai si `current - last >= limit`. \nIMPORTANT: Timestamps.", "entry_point": "rate_limit_check", "canonical_solution": "def rate_limit_check(last_ts, curr_ts, limit):\n    return (curr_ts - last_ts) >= limit", "test": "def test_rate():\n    assert rate_limit_check(100, 110, 5) is True"},
{"task_id": "CIB-A1-139", "difficulty": "Hard", "category": "Data", "prompt": "Fonction `detect_encoding` : Simule détection (si contient octets > 127 -> 'utf-8', sinon 'ascii'). \nIMPORTANT: Byte inspection.", "entry_point": "detect_encoding", "canonical_solution": "def detect_encoding(b_data):\n    if any(b > 127 for b in b_data): return 'utf-8'\n    return 'ascii'", "test": "def test_enc():\n    assert detect_encoding(b'hello') == 'ascii'\n    assert detect_encoding('été'.encode('utf-8')) == 'utf-8'"},
{"task_id": "CIB-A1-140", "difficulty": "Easy", "category": "Math", "prompt": "Fonction `is_odd` : Vrai si impair. \nIMPORTANT: Modulo.", "entry_point": "is_odd", "canonical_solution": "def is_odd(n):\n    return n % 2 != 0", "test": "def test_odd():\n    assert is_odd(3) is True"},
{"task_id": "CIB-A1-141", "difficulty": "Medium", "category": "String", "prompt": "Fonction `string_compression` : 'aabcccccaaa' -> 'a2b1c5a3'. Si pas plus court, retourne original. \nIMPORTANT: RLE logic.", "entry_point": "string_compression", "canonical_solution": "def string_compression(s):\n    res = []\n    cnt = 0\n    for i in range(len(s)):\n        cnt += 1\n        if i + 1 >= len(s) or s[i] != s[i+1]:\n            res.append(s[i] + str(cnt))\n            cnt = 0\n    compressed = ''.join(res)\n    return compressed if len(compressed) < len(s) else s", "test": "def test_comp():\n    assert string_compression('aabcccccaaa') == 'a2b1c5a3'"},
{"task_id": "CIB-A1-142", "difficulty": "Hard", "category": "List", "prompt": "Fonction `binary_search_insert` : Trouve l'index où insérer x pour garder l'ordre. \nIMPORTANT: Bisect.", "entry_point": "binary_search_insert", "canonical_solution": "import bisect\ndef binary_search_insert(l, x):\n    return bisect.bisect_left(l, x)", "test": "def test_bisect():\n    assert binary_search_insert([1, 3, 4], 2) == 1"},
{"task_id": "CIB-A1-143", "difficulty": "Easy", "category": "Conversion", "prompt": "Fonction `list_to_string` : Convertit [1, 2] en '1, 2'. \nIMPORTANT: Join map.", "entry_point": "list_to_string", "canonical_solution": "def list_to_string(l):\n    return ', '.join(map(str, l))", "test": "def test_l2s():\n    assert list_to_string([1, 2]) == '1, 2'"},
{"task_id": "CIB-A1-144", "difficulty": "Medium", "category": "Set", "prompt": "Fonction `symmetric_difference` : Éléments dans A ou B mais pas les deux. \nIMPORTANT: Operator ^.", "entry_point": "symmetric_difference", "canonical_solution": "def symmetric_difference(a, b):\n    return list(set(a) ^ set(b))", "test": "def test_sym():\n    assert 1 in symmetric_difference([1, 2], [2, 3])"},
{"task_id": "CIB-A1-145", "difficulty": "Hard", "category": "Algo", "prompt": "Fonction `levenshtein_distance` : Distance d'édition simple (récursif ou DP). \nIMPORTANT: Distance str.", "entry_point": "levenshtein_distance", "canonical_solution": "def levenshtein_distance(s1, s2):\n    if not s1: return len(s2)\n    if not s2: return len(s1)\n    if s1[0] == s2[0]: return levenshtein_distance(s1[1:], s2[1:])\n    return 1 + min(levenshtein_distance(s1[1:], s2), levenshtein_distance(s1, s2[1:]), levenshtein_distance(s1[1:], s2[1:]))", "test": "def test_lev():\n    assert levenshtein_distance('cat', 'cut') == 1"},
{"task_id": "CIB-A1-146", "difficulty": "Easy", "category": "Math", "prompt": "Fonction `perimeter_circle` : 2*pi*r. \nIMPORTANT: Math.", "entry_point": "perimeter_circle", "canonical_solution": "import math\ndef perimeter_circle(r):\n    return 2 * math.pi * r", "test": "def test_perim():\n    assert abs(perimeter_circle(1) - 6.28) < 0.1"},
{"task_id": "CIB-A1-147", "difficulty": "Medium", "category": "List", "prompt": "Fonction `check_monotonic` : Vrai si monotone croissant ou décroissant. \nIMPORTANT: 2 checks.", "entry_point": "check_monotonic", "canonical_solution": "def check_monotonic(l):\n    return l == sorted(l) or l == sorted(l, reverse=True)", "test": "def test_mono():\n    assert check_monotonic([3, 2, 1]) is True"},
{"task_id": "CIB-A1-148", "difficulty": "Hard", "category": "Dict", "prompt": "Fonction `dict_intersection` : Retourne dict avec clés/valeurs présentes dans les deux. \nIMPORTANT: Items check.", "entry_point": "dict_intersection", "canonical_solution": "def dict_intersection(d1, d2):\n    return {k: v for k, v in d1.items() if k in d2 and d2[k] == v}", "test": "def test_dict_int():\n    assert dict_intersection({'a':1, 'b':2}, {'a':1, 'c':3}) == {'a':1}"},
{"task_id": "CIB-A1-149", "difficulty": "Easy", "category": "String", "prompt": "Fonction `starts_with_vowel` : Vrai si commence par aeiou. \nIMPORTANT: lower.", "entry_point": "starts_with_vowel", "canonical_solution": "def starts_with_vowel(s):\n    return s and s[0].lower() in 'aeiou'", "test": "def test_vowel():\n    assert starts_with_vowel('Apple') is True"},
{"task_id": "CIB-A1-150", "difficulty": "Medium", "category": "Markdown", "prompt": "Fonction `md_header_to_html` : Convertit '# Titre' en '<h1>Titre</h1>'. \nIMPORTANT: String manipulation.", "entry_point": "md_header_to_html", "canonical_solution": "def md_header_to_html(md):\n    if md.startswith('# '): return f'<h1>{md[2:]}</h1>'\n    return md", "test": "def test_md():\n    assert md_header_to_html('# Test') == '<h1>Test</h1>'"}
]